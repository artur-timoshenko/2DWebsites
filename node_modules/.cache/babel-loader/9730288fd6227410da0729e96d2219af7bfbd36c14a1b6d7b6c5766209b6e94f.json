{"ast":null,"code":"import { useEffect, useReducer, useRef } from 'react';\nfunction useFetch(url, options) {\n  const cache = useRef({});\n  const cancelRequest = useRef(false);\n  const initialState = {\n    error: undefined,\n    data: undefined\n  };\n  const fetchReducer = (state, action) => {\n    switch (action.type) {\n      case 'loading':\n        return {\n          ...initialState\n        };\n      case 'fetched':\n        return {\n          ...initialState,\n          data: action.payload\n        };\n      case 'error':\n        return {\n          ...initialState,\n          error: action.payload\n        };\n      default:\n        return state;\n    }\n  };\n  const [state, dispatch] = useReducer(fetchReducer, initialState);\n  useEffect(() => {\n    if (!url) return;\n    const fetchData = async () => {\n      dispatch({\n        type: 'loading'\n      });\n      if (cache.current[url]) {\n        dispatch({\n          type: 'fetched',\n          payload: cache.current[url]\n        });\n        return;\n      }\n      try {\n        const response = await fetch(url, options);\n        if (!response.ok) {\n          throw new Error(response.statusText);\n        }\n        const data = await response.json();\n        cache.current[url] = data;\n        if (cancelRequest.current) return;\n        dispatch({\n          type: 'fetched',\n          payload: data\n        });\n      } catch (error) {\n        if (cancelRequest.current) return;\n        dispatch({\n          type: 'error',\n          payload: error\n        });\n      }\n    };\n    void fetchData();\n    return () => {\n      cancelRequest.current = true;\n    };\n  }, [url]);\n  return state;\n}\nexport default useFetch;","map":{"version":3,"mappings":"AAAA,SAASA,SAAS,EAAEC,UAAU,EAAEC,MAAM,QAAQ,OAAO;AAerD,SAASC,QAAQA,CAAcC,GAAY,EAAEC,OAAqB;EAChE,MAAMC,KAAK,GAAGJ,MAAM,CAAW,EAAE,CAAC;EAGlC,MAAMK,aAAa,GAAGL,MAAM,CAAU,KAAK,CAAC;EAE5C,MAAMM,YAAY,GAAa;IAC7BC,KAAK,EAAEC,SAAS;IAChBC,IAAI,EAAED;GACP;EAGD,MAAME,YAAY,GAAGA,CAACC,KAAe,EAAEC,MAAiB,KAAc;IACpE,QAAQA,MAAM,CAACC,IAAI;MACjB,KAAK,SAAS;QACZ,OAAO;UAAE,GAAGP;QAAY,CAAE;MAC5B,KAAK,SAAS;QACZ,OAAO;UAAE,GAAGA,YAAY;UAAEG,IAAI,EAAEG,MAAM,CAACE;QAAO,CAAE;MAClD,KAAK,OAAO;QACV,OAAO;UAAE,GAAGR,YAAY;UAAEC,KAAK,EAAEK,MAAM,CAACE;QAAO,CAAE;MACnD;QACE,OAAOH,KAAK;;EAElB,CAAC;EAED,MAAM,CAACA,KAAK,EAAEI,QAAQ,CAAC,GAAGhB,UAAU,CAACW,YAAY,EAAEJ,YAAY,CAAC;EAEhER,SAAS,CAAC,MAAK;IAEb,IAAI,CAACI,GAAG,EAAE;IAEV,MAAMc,SAAS,GAAG,YAAW;MAC3BD,QAAQ,CAAC;QAAEF,IAAI,EAAE;MAAS,CAAE,CAAC;MAG7B,IAAIT,KAAK,CAACa,OAAO,CAACf,GAAG,CAAC,EAAE;QACtBa,QAAQ,CAAC;UAAEF,IAAI,EAAE,SAAS;UAAEC,OAAO,EAAEV,KAAK,CAACa,OAAO,CAACf,GAAG;QAAC,CAAE,CAAC;QAC1D;;MAGF,IAAI;QACF,MAAMgB,QAAQ,GAAG,MAAMC,KAAK,CAACjB,GAAG,EAAEC,OAAO,CAAC;QAC1C,IAAI,CAACe,QAAQ,CAACE,EAAE,EAAE;UAChB,MAAM,IAAIC,KAAK,CAACH,QAAQ,CAACI,UAAU,CAAC;;QAGtC,MAAMb,IAAI,GAAI,MAAMS,QAAQ,CAACK,IAAI,EAAQ;QACzCnB,KAAK,CAACa,OAAO,CAACf,GAAG,CAAC,GAAGO,IAAI;QACzB,IAAIJ,aAAa,CAACY,OAAO,EAAE;QAE3BF,QAAQ,CAAC;UAAEF,IAAI,EAAE,SAAS;UAAEC,OAAO,EAAEL;QAAI,CAAE,CAAC;OAC7C,CAAC,OAAOF,KAAK,EAAE;QACd,IAAIF,aAAa,CAACY,OAAO,EAAE;QAE3BF,QAAQ,CAAC;UAAEF,IAAI,EAAE,OAAO;UAAEC,OAAO,EAAEP;QAAc,CAAE,CAAC;;IAExD,CAAC;IAED,KAAKS,SAAS,EAAE;IAIhB,OAAO,MAAK;MACVX,aAAa,CAACY,OAAO,GAAG,IAAI;IAC9B,CAAC;EAEH,CAAC,EAAE,CAACf,GAAG,CAAC,CAAC;EAET,OAAOS,KAAK;AACd;AAEA,eAAeV,QAAQ","names":["useEffect","useReducer","useRef","useFetch","url","options","cache","cancelRequest","initialState","error","undefined","data","fetchReducer","state","action","type","payload","dispatch","fetchData","current","response","fetch","ok","Error","statusText","json"],"sources":["C:\\Users\\Artur\\Desktop\\portfolio-inner-site-master\\node_modules\\usehooks-ts\\src\\useFetch\\useFetch.ts"],"sourcesContent":["import { useEffect, useReducer, useRef } from 'react'\n\ninterface State<T> {\n  data?: T\n  error?: Error\n}\n\ntype Cache<T> = { [url: string]: T }\n\n// discriminated union type\ntype Action<T> =\n  | { type: 'loading' }\n  | { type: 'fetched'; payload: T }\n  | { type: 'error'; payload: Error }\n\nfunction useFetch<T = unknown>(url?: string, options?: RequestInit): State<T> {\n  const cache = useRef<Cache<T>>({})\n\n  // Used to prevent state update if the component is unmounted\n  const cancelRequest = useRef<boolean>(false)\n\n  const initialState: State<T> = {\n    error: undefined,\n    data: undefined,\n  }\n\n  // Keep state logic separated\n  const fetchReducer = (state: State<T>, action: Action<T>): State<T> => {\n    switch (action.type) {\n      case 'loading':\n        return { ...initialState }\n      case 'fetched':\n        return { ...initialState, data: action.payload }\n      case 'error':\n        return { ...initialState, error: action.payload }\n      default:\n        return state\n    }\n  }\n\n  const [state, dispatch] = useReducer(fetchReducer, initialState)\n\n  useEffect(() => {\n    // Do nothing if the url is not given\n    if (!url) return\n\n    const fetchData = async () => {\n      dispatch({ type: 'loading' })\n\n      // If a cache exists for this url, return it\n      if (cache.current[url]) {\n        dispatch({ type: 'fetched', payload: cache.current[url] })\n        return\n      }\n\n      try {\n        const response = await fetch(url, options)\n        if (!response.ok) {\n          throw new Error(response.statusText)\n        }\n\n        const data = (await response.json()) as T\n        cache.current[url] = data\n        if (cancelRequest.current) return\n\n        dispatch({ type: 'fetched', payload: data })\n      } catch (error) {\n        if (cancelRequest.current) return\n\n        dispatch({ type: 'error', payload: error as Error })\n      }\n    }\n\n    void fetchData()\n\n    // Use the cleanup function for avoiding a possibly...\n    // ...state update after the component was unmounted\n    return () => {\n      cancelRequest.current = true\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [url])\n\n  return state\n}\n\nexport default useFetch\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}